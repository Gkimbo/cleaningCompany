/**
 * MultiCleanerJob Model
 *
 * Tracks multi-cleaner job metadata and status for large homes.
 * Links to appointment and manages cleaner slots, offers, and completion.
 */
module.exports = (sequelize, DataTypes) => {
  const MultiCleanerJob = sequelize.define("MultiCleanerJob", {
    id: {
      type: DataTypes.INTEGER,
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
    },
    appointmentId: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    totalCleanersRequired: {
      type: DataTypes.INTEGER,
      allowNull: false,
      defaultValue: 2,
    },
    cleanersConfirmed: {
      type: DataTypes.INTEGER,
      allowNull: false,
      defaultValue: 0,
    },
    status: {
      type: DataTypes.ENUM(
        "open",
        "partially_filled",
        "filled",
        "in_progress",
        "completed",
        "cancelled"
      ),
      allowNull: false,
      defaultValue: "open",
    },
    primaryCleanerId: {
      type: DataTypes.INTEGER,
      allowNull: true,
    },
    isAutoGenerated: {
      type: DataTypes.BOOLEAN,
      allowNull: false,
      defaultValue: false,
    },
    totalEstimatedMinutes: {
      type: DataTypes.INTEGER,
      allowNull: true,
    },
    openedToMarketAt: {
      type: DataTypes.DATE,
      allowNull: true,
    },
    filledAt: {
      type: DataTypes.DATE,
      allowNull: true,
    },
    urgentNotificationSentAt: {
      type: DataTypes.DATE,
      allowNull: true,
    },
    finalWarningAt: {
      type: DataTypes.DATE,
      allowNull: true,
    },
  });

  MultiCleanerJob.associate = (models) => {
    MultiCleanerJob.belongsTo(models.UserAppointments, {
      foreignKey: "appointmentId",
      as: "appointment",
    });

    MultiCleanerJob.belongsTo(models.User, {
      foreignKey: "primaryCleanerId",
      as: "primaryCleaner",
    });

    MultiCleanerJob.hasMany(models.CleanerRoomAssignment, {
      foreignKey: "multiCleanerJobId",
      as: "roomAssignments",
    });

    MultiCleanerJob.hasMany(models.CleanerJobOffer, {
      foreignKey: "multiCleanerJobId",
      as: "offers",
    });

    MultiCleanerJob.hasMany(models.CleanerJobCompletion, {
      foreignKey: "multiCleanerJobId",
      as: "completions",
    });
  };

  /**
   * Check if all cleaner slots are filled
   */
  MultiCleanerJob.prototype.isFilled = function () {
    return this.cleanersConfirmed >= this.totalCleanersRequired;
  };

  /**
   * Get remaining slots
   */
  MultiCleanerJob.prototype.getRemainingSlots = function () {
    return Math.max(0, this.totalCleanersRequired - this.cleanersConfirmed);
  };

  /**
   * Update status based on confirmed cleaners
   */
  MultiCleanerJob.prototype.updateStatus = async function () {
    if (this.cleanersConfirmed === 0) {
      this.status = "open";
    } else if (this.cleanersConfirmed < this.totalCleanersRequired) {
      this.status = "partially_filled";
    } else if (this.cleanersConfirmed >= this.totalCleanersRequired) {
      this.status = "filled";
      if (!this.filledAt) {
        this.filledAt = new Date();
      }
    }
    await this.save();
    return this;
  };

  return MultiCleanerJob;
};
