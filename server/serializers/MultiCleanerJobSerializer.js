const EncryptionService = require("../services/EncryptionService");

class MultiCleanerJobSerializer {
	static userEncryptedFields = ["firstName", "lastName", "email", "phone"];

	// Home fields that are encrypted
	static homeEncryptedFields = [
		"address",
		"city",
		"state",
		"zipcode",
		"keyPadCode",
		"keyLocation",
		"contact",
		"gateCode",
		"accessNotes",
	];

	static decryptField(value) {
		if (!value) return null;
		return EncryptionService.decrypt(value);
	}

	static decryptUserField(value) {
		if (!value) return null;
		return EncryptionService.decrypt(value);
	}

	static serializeUser(user) {
		if (!user) return null;
		const data = user.dataValues || user;
		return {
			id: data.id,
			firstName: this.decryptUserField(data.firstName),
			lastName: this.decryptUserField(data.lastName),
			type: data.type
		};
	}

	/**
	 * Serialize home with optional full address inclusion
	 * @param {Object} home - Home object
	 * @param {boolean} includeFullAddress - Whether to include full address and access details
	 */
	static serializeHome(home, includeFullAddress = true) {
		if (!home) return null;
		const data = home.dataValues || home;

		const serialized = {
			id: data.id,
			nickName: data.nickName,
			city: this.decryptField(data.city),
			state: this.decryptField(data.state),
			numBeds: data.numBeds,
			numBaths: data.numBaths,
			numHalfBaths: data.numHalfBaths,
			sqft: data.sqft,
			hasDog: data.hasDog,
			dogName: data.dogName,
			hasCat: data.hasCat,
			catName: data.catName,
			timeToBeCompleted: data.timeToBeCompleted,
			cleanersNeeded: data.cleanersNeeded,
			// Include coordinates for distance calculations (not sensitive)
			latitude: data.latitude,
			longitude: data.longitude,
		};

		// Only include sensitive address and access details when allowed
		if (includeFullAddress) {
			serialized.address = this.decryptField(data.address);
			serialized.zipcode = this.decryptField(data.zipcode);
			serialized.hasGate = data.hasGate;
			serialized.gateCode = this.decryptField(data.gateCode);
			serialized.accessNotes = this.decryptField(data.accessNotes);
			serialized.contact = this.decryptField(data.contact);
		}

		return serialized;
	}

	/**
	 * Check if appointment date is within 48 hours from now
	 * @param {string} dateString - Appointment date (YYYY-MM-DD)
	 * @returns {boolean}
	 */
	static isWithin48Hours(dateString) {
		if (!dateString) return false;
		const now = new Date();
		// Assume 10am start time for the appointment
		const appointmentDate = new Date(dateString + "T10:00:00");
		const diffTime = appointmentDate.getTime() - now.getTime();
		const diffHours = diffTime / (1000 * 60 * 60);
		return diffHours <= 48 && diffHours >= 0;
	}

	/**
	 * Serialize appointment with optional full address
	 * @param {Object} appointment - Appointment object
	 * @param {boolean} includeFullAddress - Whether to include full address
	 */
	static serializeAppointment(appointment, includeFullAddress = true) {
		if (!appointment) return null;
		const data = appointment.dataValues || appointment;
		return {
			id: data.id,
			date: data.date,
			price: data.price,
			bringTowels: data.bringTowels,
			bringSheets: data.bringSheets,
			timeToBeCompleted: data.timeToBeCompleted,
			completed: data.completed,
			isMultiCleanerJob: data.isMultiCleanerJob,
			home: appointment.home ? this.serializeHome(appointment.home, includeFullAddress) : null,
		};
	}

	/**
	 * Serialize a multi-cleaner job
	 * @param {Object} job - Job object
	 * @param {boolean} includeFullAddress - Whether to include full address (default: true for confirmed within 48h)
	 */
	static serializeOne(job, includeFullAddress = null) {
		const data = job.dataValues || job;

		// If includeFullAddress not specified, determine based on appointment date
		if (includeFullAddress === null && job.appointment) {
			const appointmentDate = job.appointment.dataValues?.date || job.appointment.date;
			includeFullAddress = this.isWithin48Hours(appointmentDate);
		} else if (includeFullAddress === null) {
			includeFullAddress = false;
		}

		const serialized = {
			id: data.id,
			appointmentId: data.appointmentId,
			totalCleanersRequired: data.totalCleanersRequired,
			cleanersConfirmed: data.cleanersConfirmed,
			status: data.status,
			primaryCleanerId: data.primaryCleanerId,
			isAutoGenerated: data.isAutoGenerated,
			totalEstimatedMinutes: data.totalEstimatedMinutes,
			openedToMarketAt: data.openedToMarketAt,
			filledAt: data.filledAt,
			urgentNotificationSentAt: data.urgentNotificationSentAt,
			finalWarningAt: data.finalWarningAt,
			createdAt: data.createdAt,
			updatedAt: data.updatedAt
		};

		// Computed properties
		serialized.isFilled = data.cleanersConfirmed >= data.totalCleanersRequired;
		serialized.remainingSlots = Math.max(0, data.totalCleanersRequired - data.cleanersConfirmed);

		// Serialize primary cleaner if included
		if (job.primaryCleaner) {
			serialized.primaryCleaner = this.serializeUser(job.primaryCleaner);
		}

		// Serialize room assignments if included
		if (job.roomAssignments) {
			serialized.roomAssignments = job.roomAssignments.map(assignment =>
				this.serializeRoomAssignment(assignment)
			);
		}

		// Serialize offers if included
		if (job.offers) {
			serialized.offers = job.offers.map(offer =>
				this.serializeOffer(offer)
			);
		}

		// Serialize completions if included
		if (job.completions) {
			serialized.completions = job.completions.map(completion =>
				this.serializeCompletion(completion)
			);
		}

		// Serialize appointment if included
		if (job.appointment) {
			serialized.appointment = this.serializeAppointment(job.appointment, includeFullAddress);
		}

		return serialized;
	}

	static serializeArray(jobs, includeFullAddress = null) {
		return jobs.map((job) => this.serializeOne(job, includeFullAddress));
	}

	static serializeRoomAssignment(assignment) {
		const data = assignment.dataValues || assignment;

		const serialized = {
			id: data.id,
			multiCleanerJobId: data.multiCleanerJobId,
			cleanerId: data.cleanerId,
			rooms: data.rooms,
			estimatedMinutes: data.estimatedMinutes,
			status: data.status,
			startedAt: data.startedAt,
			completedAt: data.completedAt,
			createdAt: data.createdAt
		};

		// Serialize cleaner if included
		if (assignment.cleaner) {
			serialized.cleaner = this.serializeUser(assignment.cleaner);
		}

		return serialized;
	}

	static serializeOffer(offer) {
		const data = offer.dataValues || offer;

		const serialized = {
			id: data.id,
			multiCleanerJobId: data.multiCleanerJobId,
			cleanerId: data.cleanerId,
			appointmentId: data.appointmentId,
			offerType: data.offerType,
			status: data.status,
			earningsOffered: data.earningsOffered,
			roomsOffered: data.roomsOffered,
			offeredAt: data.offeredAt,
			respondedAt: data.respondedAt,
			expiresAt: data.expiresAt,
			createdAt: data.createdAt
		};

		// Serialize multiCleanerJob if included (with nested appointment/home)
		// Offers are for unconfirmed cleaners, so never include full address
		if (offer.multiCleanerJob) {
			serialized.multiCleanerJob = this.serializeOne(offer.multiCleanerJob, false);
		}

		return serialized;
	}

	static serializeCompletion(completion) {
		const data = completion.dataValues || completion;

		return {
			id: data.id,
			multiCleanerJobId: data.multiCleanerJobId,
			cleanerId: data.cleanerId,
			completedAt: data.completedAt,
			notes: data.notes,
			createdAt: data.createdAt
		};
	}

	static serializeForList(job) {
		const data = job.dataValues || job;

		return {
			id: data.id,
			appointmentId: data.appointmentId,
			totalCleanersRequired: data.totalCleanersRequired,
			cleanersConfirmed: data.cleanersConfirmed,
			status: data.status,
			isFilled: data.cleanersConfirmed >= data.totalCleanersRequired,
			remainingSlots: Math.max(0, data.totalCleanersRequired - data.cleanersConfirmed)
		};
	}

	static serializeArrayForList(jobs) {
		return jobs.map((job) => this.serializeForList(job));
	}

	static serializeOfferArray(offers) {
		return offers.map((offer) => this.serializeOffer(offer));
	}

	/**
	 * Serialize offers response for the /offers endpoint
	 * Includes both personal offers and available jobs
	 * Note: Full address is never included for offers/available jobs (cleaner not confirmed)
	 */
	static serializeOffersResponse(personalOffers, availableJobs) {
		return {
			personalOffers: this.serializeOfferArray(personalOffers),
			// Available jobs are unconfirmed, so never include full address
			availableJobs: this.serializeArray(availableJobs, false),
		};
	}
}

module.exports = MultiCleanerJobSerializer;
